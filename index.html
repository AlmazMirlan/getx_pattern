<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
  <title>getx_pattern alpha</title>
  <meta name="description" content="Design pattern pensado em você, que utiliza o package Get">
  
	<link rel="stylesheet" href="styles.css">
	<script src="https://kit.fontawesome.com/b99e675b6e.js"></script>
</head>
<body>
  <!------preview image link -->
  <meta property="og:url" content="https://kauemurakami.github.io/getx_pattern/" />
  <meta property="og:title" content="getx_pattern" />
  <meta property="og:description" content="getx_pattern, faça seus projetos decolarem" >
  <meta property="og:image" content="images/rocket.png">
  <meta property="og:locale" content="pt_BR" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="article" />

<div class="wrapper">
    <div class="sidebar">
        <h2>getx_pattern <span class="alpha"> alpha</span><i class="fas fa-rocket"></i></h2>
        <ul>
            <li><a href="#home"><i class="fas fa-home"></i>Home</a></li>
            <li><a href="#estrutura"><i class="fas fa-project-diagram"></i>Estrutura</a></li>
            <li><a href="#getx"><i class="fab fa-xing"></i>  GetX</a></li>
            <li><a href="#data"><i class="fas fa-sitemap"></i>Data</a></li>
            <li><a href="#provider"><i class="fas fa-database"></i>Provider</a></li>
            <li><a href="#model"><i class="fas fa-copy"></i>Model</a></li>
            <li><a href="#repository"><i class="fas fa-archive"></i></i>Repository</a></li>
            <li><a href="#controller"><i class="fas fa-gamepad"></i>Controller</a></li>
            <li><a href="#ui"><i class="fas fa-mobile-alt"></i>UI</a></li>
            <li><a href="#routes"><i class="fas fa-road"></i>Routes</a></li>
            <li><a href="#info"><i class="fas fa-info-circle"></i></i>Informações</a></li>
        </ul> 
        <div class="social_media">
          <a href="https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets" title="GetX Snippets VSCode Extension" target="_blank"><i class="fas fa-laptop-code"></i></a>
          <a href="https://twitter.com/kauemurakami" title="Quick questions? Developer Twitter" target="_blank"><i class="fab fa-twitter"></i></a>
          <a href="https://github.com/kauemurakami/getx_pattern" title="GitHub repository" target="_blank"><i class="fab fa-github"></i></a>
      </div>
    </div>
    <div class="main_content"> 
        <div class="info">

          <section id="home">
            <div><h2><span class="subtitle">getx_pattern, uma proposta pra você que utiliza o 
              <a href="https://pub.dev/packages/get" target="_blank">GetX</a></span></h2></div>
          <div>
            Projeto desenvolvido para padronizar os seus projetos com <a href="https://pub.dev/packages/get" target="_blank">GetX</a>.<br><br>
            <span class="subtitle"><h2>Objetivos</h2></span>
            O objetivo principal, é tornar sua programação com <font color="blue">Flutter</font> + <a href="https://pub.dev/packages/get" target="_blank">GetX</a> 
            mais agradável e intuitiva do que já é <span class="mark">!</span><br>
            Quando há um padrão de desenvolvimento a ser seguido, tudo fica mais fácil para quem usa. <span class="mark">Mas por quê?</span><br><br>
            - <span class="mark">Porque</span> assim, podemos nos comunicar de forma "universal" com pessoas que também seguem esses mesmos padrões.<br><br>
            - <span class="mark">Há</span> infinitas maneiras de resolver o mesmo problema, então os patterns tem um papel muito importante nisso, 
            os mesmos problemas, ainda poderão ser resolvidos de várias maneiras, mas com um determinado fluxo a ser seguido.<br><br>
            - <span class="mark">Com</span> isso é muito mais fácil sanar suas dúvidas, quando vocês conversam no mesmo padrão.<br><br>
            - <span class="mark">Seu</span> projeto não ficará dependente de quem o construiu, pois outros programadores poderão ler e alterar o código sem dificuldades.<br><br>
            - <span class="mark">Você</span> terá um melhor aproveitamento na reutilização do seu código, podendo assim reutilizar diversos widgets de outros projetos 
            por exemplo, que ele se encaixará perfeitamente no seu projeto.<br><br>
            - <span class="mark">Que</span> você possa aplicar o uso do <a href="https://pub.dev/packages/get" target="_blank">GetX</a> em projetos profissionais, 
            tendo uma documentação em mãos, com isso, mais segurança para quem programa, seja você uma empresa ou um estudante em busca de conhecimento.<br>
            <div class="obs">
              <span class="mark">E</span> além do <span class="mark">getx_pattern</span>, também está disponibilizamos uma extensão que irá acelerar muito mais ainda esse processo,
              o <a href="https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets" target="_blank">GetX Snippets</a>
              tem snippets que irão acelerar seu desenvolvimento, podendo criar desde variáveis a classes inteiras e já está disponível para 
              o <span class="mark">vscode, Experimente !</span><br>
            </div>
            Agora que você entendeu nossos objetivos, vamos aprender um pouco sobre a <span class="mark">estrutura</span> do <span class="mark">getx_pattern</span> !
          
          </div>
          </section>

          <section id="estrutura">
            <div><h2><span class="subtitle">Estrutura</span></h2></div>
          <div>
            <img src="images/strc.png" alt="The Structure for GetX developers xD" width="500" height="600" class="center"><br>
            Agora que você conhece a <span class="mark">proposta</span> e deu uma boa analisada na apresentação da estrutura, vamos parar um pouco para falar rapidamente sobre ela, 
            antes de introduzir você na seção do <span class="mark">GetX</span>, para que você possa seguir nossos exemplos sem dificuldade 
            ou dúvidas sobre nossos padrões de nomenclatura ou fluxo, pois bem, vamos falar <span class="mark">rapidamente de um por um</span> agora, <span class="mark">não se preocupe</span> se você está 
            se aventurando e não conhece alguns dos <span class="mark">conceitos</span> que serão abordados aqui, isso é apenas uma apresentação formal com a estrutura, 
            iremos falar mais <span class="mark">detalhadamente sobre cada uma delas</span>, com exemplos, em suas respectivas seções.<br><br>
            
            <i class="fas fa-copy alpha"></i> <span class="mark topics">Model</span>: É o diretório que irá agrupar todas as nossas classes modelos para nossos objetos.<br>
            <div class="obs">Sinta-se a vontade para escolher entre <span class="mark">Model</span> ou <span class="mark">Class</span>, mas tenha em mente que daqui em diante, usarei o termo 
              Model, caso não seja novidade, garanto que logo irá se acostumar com <span class="mark">Model.</span>
            </div>
            
            <i class="fas fa-database alpha"></i> <span class="mark topics">Providers</span>: É o diretório responsável por agrupar nossos <span class="mark">provedores de dados</span>, 
            pode ser tanto um <span class="mark">banco de dados</span> ou uma <span class="mark">api</span>.<br><br>
            

            <i class="fas fa-archive alpha"></i> <span class="mark topics">Repository</span>: É um ponto <span class="mark">único</span> de acesso aos dados, irá abstrair nossas 
            <span class="mark">entidades</span>.<br><br>

            <i class="fas fa-sitemap alpha"></i> <span class="mark topics">Data</span>: É apenas um diretório responsável por guardar <span class="mark">TUDO</span> 
            relacionado aos seus dados, ou seja, seu <span class="mark">repository</span>, suas <span class="mark">classes</span> e <span class="mark">providers</span>.
            <br><br>
            <i class="fas fa-gamepad alpha"></i> <span class="mark topics">Controller</span>: Nossos controllers, nada mais são, que os responsáveis pelas nossas 
            <span class="mark">regras de negócio</span>, <span class="mark">alterações de estado</span>, também é onde criaremos 
            <span class="mark">nossos observáveis</span> com seus respectivos <span class="mark">estados iniciais</span> e 
            os <span class="mark">eventos</span> que serão responsáveis por <span class="mark">alterar esses estados</span>.
           <br><br>

            <i class="fas fa-mobile alpha"></i> <span class="mark topics">UI</span>: É tudo que o usuário vê, seus widgets, animações, textos, temas.
            <br><br>

            <i class="fas fa-road alpha"></i> <span class="mark topics">Routes</span>: É o diretório responsável por conter o/os nossos arquivos que são resposáveis por gerênciar nossas rotas.
            




          </div>
          </section>

          <section id="getx">
            <div><h2><span class="subtitle">GetX, seu gerenciador de estado reativo.</span></h2></div>
            <div><div class="obs">Primeiramente, é aconselhável que você tenha um conhecimento prévio de <span class="mark">flutter</span> e também uma base 
              de conhecimento em <span class="mark">gerenciamento de estados</span>, caso não tenha, recomendo uma breve leitura na 
              <span class="mark">documentação oficial</span> do <span class="mark">flutter</span> 
              sobre este assunto, para acessar click <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro" target="_blank">aqui</a>.<br></div>
              O foco do <span class="mark">GetX</span> é ter <span class="mark">maior desempenho</span> com o <span class="mark">mínimo consumo de recursos</span>, veja os 
                <a href="https://github.com/jonataslaw/benchmarks" target="_blank"> benchmarks</a>.<br>
                 <span class="mark">Produtividade</span>, usando uma sintaxe <span class="mark">fácil</span> e <span class="mark">agradável</span>.<br>
                 <span class="mark">Organização</span>, permitindo a <span class="mark">dissociação total</span> da sua camada de 
                 <span class="mark">apresentação</span> da sua <span class="mark">regra de negócio</span>.<br>
                  O <span class="mark">Getx</span> tem o poder de reconstruir apenas o widget quando há uma alteração de estado em uma variável 
                  <span class="mark">.obs</span> em seu controlador. Isso, porque <span class="mark">tudo nele é fluxo</span>, isso nos permite 
                  ouvir o evento de cada 'variável'.<br>
                  Vamos para um primeiro exemplo da aplicação do <span class="mark">GetX</span> com <span class="mark">o getx_pattern</span>
                  , do bom e velho contador.<br><br>

                  Vamos utilizar, neste exemplo, apenas a classe main, para você se familiarizar com os conceitos do 
                  <span class="mark">GetX</span>.<br>
                  Apague todo conteúdo da sua main.dart e mantenha, ou copie e cole, apenas este trecho de código:

                  <script src="https://gist.github.com/kauemurakami/fdbc297925a693e1840b5a255c8744dc.js"></script>
                  Após isso, vamos criar nossa classe controller, que nos permite criar nossa regra de negócio e controlar nossos estados.<br>
                  Abaixo do código acima cole o seguinte código:
                  <script src="https://gist.github.com/kauemurakami/0b2e62e0cedb0bfdbcbe0836f84cbc11.js"></script>
                  O <span class="mark">RxController</span>  é o responsável por nos fornecer os métodos necessários para controllar nossos
                  observáveis (<span class="mark">.obs</span>), permitindo atualizar nossos widgets GetX, respondendo as mudanças de 
                  estados da nossa aplicação.
                  No exemplo acima declaramos uma variável e dois métodos, vamos falar sobre eles.<br><br>
                  Com <span class="mark">GetX</span>, podemos extender a classe <span class="mark">RxController</span>, e com ele podemos 
                  criar varáveis observáveis adicionando um simples <span class="mark">.obs</span> e <span class="mark">seu estado inicial</span>.<br>
                  <span class="mark"> final [var] = [initial-value].obs;</span> <br>
                  Nosso observável só pode ser <span>final</span>, e seu tipo será atribuido a partir do <span class="mark">initial-value</span> 
                  inserido no momento da declaração, por ser <span>final</span>, o mesmo só pode ser inserido uma vez.<br><br>

                  <span class="mark">Mas e agora?</span> Se final só pode ser modificada uma vez, como vou alterar o valor dessa variável?<br>
                  A resposta é tão simples quanto curta, <span class="mark">.value</span>. Ao criar sua variável como um observável, ela irá criar, 
                  por trás do capô, um ObjectX,exemplo, um tipo int <i class="fas fa-chevron-right mark"></i> intX, um tipo List< User>() <i class="fas fa-chevron-right mark"></i> 
                  ListX< User>(), e seu valor e tipo original é guardado no seu atributo <span>value</span> desse ObjectX.<br>
                  No caso das nossas <span class="mark">Listas</span>, não é necessário utilizar o <span class="mark">.value</span>, 
                  então diferente de um <span class="mark">StringX</span> onde você acessaria o valor contido com <span class="mark">text.value</span>, com as listas você pode trabalhar normalmente, tendo 
                  em vista que tanto sua lista, como os objetos dentro dela, são todos observáveis, portanto podemos acessar seus atributos dessa maneira 
                  <span class="mark">myList.length</span> ou <span class="mark">myList[index].name</span>.<br><br>

                  Vamos a classe Stateless, responsável pela vizualização do nosso contador. Você não leu errado, com <span class="mark">GetX</span> 
                  você nunca mais irá precisará um <span class="mark">stateful</span> quando quiser alterar seus estados, <span class="mark">esqueça o setState</span>, 
                  nosso widget <span>GetX</span> é reconstruido sempre que um objeto, nele contido, tenha o estado alterado pelo 
                  <span class="mark">controller</span> setado no widget.<br> 
                  vamos ao código.
                  <script src="https://gist.github.com/kauemurakami/7788d19e7dc98769f316c4021eca2635.js"></script>
                  Bem, isso é um widget básico, estamos apenas mostrando um text e dois botões responsáveis por acionar os nossos eventos 
                  <span class="mark">decrement()</span> e <span class="mark" >increment()</span>, lembra? estão no nosso controller <i class="fas fa-gamepad"></i>.<br>
                  Repare um pouco melhor, a primeira coisa que deve ter notado é que estamos utilizando <span class="mark">3 GetX</span>
                  widgets, <span class="mark">mas porquê</span>?<br>
                  Bem, isso deve ser abordado primeiro para que você pode entender como aplicar melhor este widget, e não usá-lo de forma,não errada, 
                  mas desnecessária, pois bem, primeiro temos um <span>GetX</span> widget do tipo <span class="mark">MyController</span>, 
                  onde nossa lógica se encontra.<br><br>

                  Mas o que ele tem diferente dos outros ? Bem, a propriedade <span class="mark">init</span>, ela é responsável por criar nossa instancia do 
                  objeto <span>controller</span> e dispinibiliza-lo na função builder desde widget, você já deve ter percebido, mas é isso mesmo, 
                  nosso <span class="mark">controllador</span> corresponde ao nosso <span class="mark">_</span> (underline), com isso você pode acessar seus 
                  observáveis apenas usando a instância do seu controlador, dessa forma <span class="mark">_.num</span>.<br>
                  Agora que temos nosso primeiro widget <span class="mark">GetX</span> com controlador inicializado, não precisamos inicializa-lo novamente, 
                  apenas setar o tipo no dele,caso estejam na mesma classe/page, dessa forma <span class="mark"> Getx<[type]></span>, e ele se encarregará do resto para você, fácil não? E 
                  você pode ficar tranquilo, sem boilerplate, o <span class="mark">GetX</span> é sensacional, e ainda sabe a hora certa de remover esse 
                  controlador da memória. Você também pode controllar isso se quiser, com <span class="mark">GetX</span> é assim, ele deixa você livre 
                  para focar na qualidade do seu código, sem se preocupar com questões repetitivas e fáceis de lidar como essa, ele cuida de tudo pra você.
                  <br>
                  Mas e o <span class="mark">.value</span>?<br>
                  Bem, é ai que entra uma das propostas do <span class="mark">getx_pattern</span>, nós achamos melhor manter tudo que for controlado 
                  na interface dentro do controlador, isso inclui os estados de suas variáveis e os eventos que levarão a isso, assim como nosso exemplo 
                  temos a variável num, que é declarado no controller e a mesma, é usada no Getx widget, e nossas funções/eventos, responsáveis por 
                  alterar o estado dessa nossa variável. Portanto, carregar <span class="mark">_.num.value</span> vai contra as boas práticas, preferimos 
                  que o controllador seja responsável até por isso, criando um <span class="mark">get</span> e um <span class="mark">set</span> para que 
                  possamos abstrair o <span class="mark">.value</span> do código da sua vizualização, deixando seu código mais legível e sem boilerplate.<br><br>             
                  Isso foi uma breve introdução sobre o uso do<span class="mark">GetX</span>, vamos aplicar isso também em outros instantes, se você não entendeu tudo até
                  aqui, não se preocupe.<br>
                  Se quer saber mais sobre o <span class="mark">GetX</span>, visite seu <span class="mark"><a href="https://pub.dev/packages/get" target="_blank">
                    package no pubdev</span></a>, ou seu repositório no <span class="mark"><a href="https://github.com/jonataslaw/get" target="_blank">GitHub aqui</span>.
            </div>
          </section> 
          <section id="data">
            <div><h2><span class="subtitle">Data</span></h2></div>
          <div>Aqui não teremos muitos o que discutir, é apenas um repositório onde você irá abstrair/empacotar <span class="mark">TUDO</span> 
            relacionado aos seus dados, seus <span class="mark"> modelos</span>, seus <span class="mark">repositories</span> e 
            <span class="mark">provedores</span> de dados. Isso foi pensado para que você possa manter sua estrutura de diretórios o 
            <span class="mark">menor possível</span> ao trabalhar com flutter e ao mesmo tempo, ser algo <span class="mark">intuitivo</span> e 
            <span class="mark">didático</span>.</div>
          </section>
          <section id="provider">
            <div><h2><span class="subtitle">Provider</span></h2></div>
            <div class="obs">
              Em algumas outras estruturas, o termo <span class="mark">'provider'</span>, pode ser abordado de várias formas, mas aqui, ele existe 
              única e exclusivamente, para fazer requisições http ou persistência num banco de dados sqlite. <span class="mark">Caso você use os dois</span>, crie os 
              respectivos diretórios e/ou arquivos dentro deste.<br>
              Caso haja <span class="mark">muitas requisições, em um único arquivo</span>, você pode optar por separar por <span class="mark">entidades</span>, vamos discutir o 
              conceito de entidades na seção abaixo. 
            </div>
          </section>
          <section id="model">
            <div><h2><span class="subtitle">Model</span></h2></div>
          <div>Lorem ipsum dolor sit, amet consectetur adipisicing elit. A sed nobis ut exercitationem atque accusamus sit 
            natus officiis totam blanditiis at eum nemo, nulla et quae eius culpa eveniet voluptatibus repellat illum tenetur, 
            facilis porro. Quae fuga odio perferendis itaque alias sint, beatae non maiores magnam ad, veniam tenetur atque ea
             exercitationem earum eveniet totam ipsam magni tempora aliquid ullam possimus? Tempora nobis facere porro, 
             praesentium magnam provident accusamus temporibus! Repellendus harum veritatis itaque molestias repudiandae 
             ea corporis maiores non obcaecati libero, unde ipsum consequuntur aut consectetur culpa magni omnis vero odio
              suscipit vitae dolor quod dignissimos perferendis eos? Consequuntur!</div>
          </section>
          <section id="repository">
            <div><h2><span class="subtitle">Repository</span></h2></div>
            <div class="obs">
              <span class="mark">Entidades </span> são, basicamente, todas as "tabelas" da sua base de dados que irão interagir com seu ou seus <span class="mark">providers</span>.<br>
              O <span class="mark">repository</span> tem o objetivo de abstrair e separar, sua fonte de dados do seus controladores, tendo assim, 
              um ponto único de falha, ou seja, se um dia você vier a trocar a api ou base de dados do seu projeto, basta alterar seus arquivos no <span class="mark">provider</span>, 
              não sendo necessário nenhuma alteração no <span class="">repository, pois ele só é responsável por chamar a função do <span class="mark">provider</span>, não havendo lógica nenhuma ali.<br>
              <span class="mark">ex</span> Imagine que você possua um aplicativo de venda de produtos, que possua apenas os clientes e os produtos de um estabelecimento.<br>
              Podemos identificar facilmente nossas <span class="mark">entidades</span> nos fazendo uma pergunta.<br>
              <span class="mark">Irei receber e/ou enviar dados dessa entidade? </span>Se a resposta for sim, então ela precisa de um repository.<br>
              No nosso exemplo teríamos três <span class="mark">repositories,</span> UserRepository, ProdutoRepository, EstabelecimentoRepository.<br>
              Muitas vezes, podemos tirar essas entidades nos baseando em nossas classes, mas muitas vezes existem classes auxiliares que não estão 
              necessariamente na sua base de dados ou api, portanto preferimos nos basear no que realmente interage com sua base de dados.
            </div>
            Dessa forma, tiramos muita responsabilidade do nosso <span class="mark">controller</span>, ele não precisa saber de onde vem os dados, 
            apenas consumi-los, outra vantagem é que o repository faz a nossa ligação Controller <span class="mark"><-> </span>Dados.<br>
            Tendo assim, uma melhor organização, deixando o código compreensivo e é extremamente fácil a manutenção, deixando tudo mais intuitivo.<br><br>
          </section>
          <section id="controller">
            <div><h2><span class="subtitle">Controller</span></h2></div>
            <div class="obs">
              Os controladores são a parte vital da sua aplicação, neles você irá criar suas variáveis <span class="mark">.obs</span> 
              que guardará valores que podem ser alterados durante a aplicação.<br>
              Seu controlador é responsável também por <span class="mark">consumir seus dados</span>>, através dos seus 
              <span class="mark">repositórios</span>, que por sua vez, só realizam as chamadas dos dados dos seus <span class="mark">providers</span><br>
              <span class="mark">Regra</span>: Todo controller deve possuir <span class="mark">um, e apenas um, repository</span>, sendo esse, 
              um atributo <span class="mark">requerido</span> para inicializar seu controller no seu <span class="mark">GetX</span> widget.<br>
              Caso você venha a precisar de dados de dois repositories diferentes em uma mesma page, você deve usar dois <span class="mark">GetX</span> widgets.
              Recomendamos que haja, no mínimo, <span class="mark">um controller para cada page</span>.<br>
              Só existe uma exceção para que você possa usar o mesmo controllador para varias pages, e é bem simples:<br>
              <span class="mark">IMPORTANTE</span> <br>
              Você poderá usar <span class="mark">um controlador</span> em <span class="mark">várias páginas</span>, 
              <span class="mark">única e exclusivamente</span>, se os dados de <span class="mark">todas as pages</span>, 
              <span class="mark">consumirem um único repositório</span>.
            
            </div>
          
              <section id="ui">
                <div><h2><span class="subtitle">UI</span></h2></div>
                <div class="obs">
                  Também temos uma proposta de como você deve agrupar esses elementos internamente.<br>
                  Vamos adiantar um pouco o assunto, pra essa ideia não ficar vazia em sua cabeça.<br>
                  Uma das maiores <span class="marl">vantagens</span> do flutter é o modo como fica fácil "<span class="mark">componentizar</span>" sua<span class="mark"> UI</span>, portanto neste diretório 
                  você deve criar <span class="mark">um diretório para cada page</span>, neste diretório, além da sua page, 
                  podemos adicionar um outro diretório, de <span class="mark">widgets para cada page</span>, dessa forma sua 
                  page principal pode ser <span class="mark">lida facilmente</span>, pois é montada com <span class="mark">vários widgets</span>.<br>
                  E se você já adivinhou, podemos fazer isso também no nivel da <span class="mark">UI</span>, criando um diretório de <span class="mark">widgets globais</span>, 
                  que virão a ser utilizados em <span class="mark">mais de uma page</span> na sua aplicação.<br>
                  Caso você não precise usar widgets em determinada page, basta ignorar essa orientação, mas <span class="mark">sempre que for criar uma page</span>, preferimos 
                  que você <span class="mark">crie um diretório para ela</span>, pois <span class="mark">futuramente</span>  pode vir a ter widgets externos à ela, 
                  dessa maneira você não irá perder tempo resolvendo erros de importação.
                </div>
              
                  <section id="routes">
                    <div><h2><span class="subtitle">Rotas</span></h2></div>
                 <div class="obs">
                  A ideia é que você possa gerenciar suas rotas de forma fácil e limpa.<br>
                  Chega de ficar procurando um widget que linka uma determinada rota a outra page, agrupe todas suas rotas e saiba exatamente onde procurar.<br>
                  Além do seu código da <span class="mark">UI</span> ficar menor usando as rotas do <span class="mark">GetX</span>, ficam muito bem apresentados quando nomeados, e 
                  agrupados de forma separada.<br>
                  Você verá exemplos disso na respectiva seção, estamos quase lá :D.
                </div>
                  
          <section id="info">
            <div><h2><span class="subtitle">Informações.</span></h2></div>
            <div>Lorem ipsum dolor sit, amet consectetur adipisicing elit. A sed nobis ut exercitationem atque accusamus sit 
              natus officiis totam blanditiis at eum nemo, nulla et quae eius culpa eveniet voluptatibus repellat illum tenetur, 
              facilis porro. Quae fuga odio perferendis itaque alias sint, beatae non maiores magnam ad, veniam tenetur atque ea
               exercitationem earum eveniet totam ipsam magni tempora aliquid ullam possimus? Tempora nobis facere porro, 
               praesentium magnam provident accusamus temporibus! Repellendus harum veritatis itaque molestias repudiandae 
               ea corporis maiores non obcaecati libero, unde ipsum consequuntur aut consectetur culpa magni omnis vero odio
                suscipit vitae dolor quod dignissimos perferendis eos? Consequuntur!</div>
          </section>
      </div>
    </div>
</div>

</body>
</html>